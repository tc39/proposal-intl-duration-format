<!doctype html>
<meta charset="utf8">
<pre class="metadata">
title: Intl.DurationFormat
stage: 1
contributors: Ujjwal Sharma, Younies Mahmoud
</pre>
<emu-biblio href="./biblio.json"></emu-biblio>
<emu-clause id="durationformat-objects">
  <h1>DurationFormat Objects</h1>

  <emu-clause id="sec-intl-durationformat-abstracts">
    <h1>Abstract Operations for DurationFormat Objects</h1>

    <p>Several DurationFormat algorithms use values from the following table, which provides internal slots and property names for Duration instances, and which is also used to key Records of templates to format individual Duration components:</p>

    <emu-table id="table-duration-components">
      <emu-caption>Components of Duration Instances</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Internal Slot</th>
            <th>Property</th>
          </tr>
        </thead>
        <tr>
          <td>[[Years]]</td>
          <td>`"years"`</td>
        </tr>
        <tr>
          <td>[[Months]]</td>
          <td>`"months"`</td>
        </tr>
        <tr>
          <td>[[Weeks]]</td>
          <td>`"weeks"`</td>
        </tr>
        <tr>
          <td>[[Days]]</td>
          <td>`"days"`</td>
        </tr>
        <tr>
          <td>[[Hours]]</td>
          <td>`"hours"`</td>
        </tr>
        <tr>
          <td>[[Minutes]]</td>
          <td>`"minutes"`</td>
        </tr>
        <tr>
          <td>[[Seconds]]</td>
          <td>`"seconds"`</td>
        </tr>
        <tr>
          <td>[[Milliseconds]]</td>
          <td>`"milliseconds"`</td>
        </tr>
        <tr>
          <td>[[Microseconds]]</td>
          <td>`"microseconds"`</td>
        </tr>
        <tr>
          <td>[[Nanoseconds]]</td>
          <td>`"nanoseconds"`</td>
        </tr>
      </table>
    </emu-table>

    <emu-note type=editor>The [[Weeks]] field is still under discussion in Temporal. For more, check out the <a href="https://github.com/tc39/proposal-temporal/issues/532">Github thread</a> on the Temporal issue tracker.</emu-note>

    <emu-clause id="sec-partitiondurationpattern" aoid="PartitionDurationPattern">
      <h1>PartitionDurationPattern ( _duration_, _dataLocale_, _style_, _numberFormat_, _pluralRules_, _listFormat_ [ , _fields_ ] )</h1>

      <p>The PartitionDurationPattern abstract operation is called with the arguments _duration_ (which must be a Record with the fields enumerated in <emu-xref href="#table-duration-components"></emu-xref>), _dataLocale_ (a locale), _style_ (one of *"long"*, *"short"*, *"narrow"*), _numberFormat_ (an `Intl.NumberFormat` object), _pluralRules_ (an `Intl.PluralRules` object), _listFormat_ (an `Intl.ListFormat` object, and optionally _fields_ (a List of Strings), and creates the corresponding parts. The following steps are taken:</p>

      <emu-alg>
        1. If _fields_ is *undefined*, then
          1. Set _fields_ to « *"years"*, *"months"*, *"weeks"*, *"days"*, *"hours"*, *"minutes"*, *"seconds"*, *"milliseconds"*, *"microseconds"*, *"nanoseconds"* ».
        1. Let _localeData_ be %DurationFormat%.[[LocaleData]].
        1. Let _patterns_ be _localeData_.[[&lt;_dataLocale_&gt;]].[[formats]].[[&lt;_style_&gt;]].
        1. Let _list_ be « ».
        1. For each row in <emu-xref href="#table-duration-components"></emu-xref>, except the header row, in table order, do
          1. Let _value_ be the value of _duration_'s field whose name is the Internal Slot value of the current row.
          1. Let _field_ be the Property value of the current row.
          1. If _value_ is not *undefined* and _fields_ contains _field_, then
            1. Let _unit_ be ! SingularRelativeTimeUnit(_field_).
            1. Let _pr_ be ! ResolvePlural(_pluralRules_, _value_).
            1. Let _pattern_ be _patterns_.[[&lt;_field_&gt;]].[[&lt;_pr_&gt;]].
            1. Let _formattedValue_ be ! PartitionNumberPattern(_numberFormat_, _value_).
            1. Let _parts_ be ! MakePartsList(_pattern_, _unit_, _formattedValue_).
            1. Append _parts_ to _list_.
        1. Let _result_ be ! CreatePartsFromList(_listFormat_, _list_).
        1. <mark>TODO: Perhaps we want to merge adjacent literals.</mark>
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-partitiondurationformatpattern" aoid="PartitionDurationFormatPattern">
      <h1>PartitionDurationFormatPattern ( _durationFormat_, _duration_ )</h1>

      <p>The PartitionDurationFormatPattern abstract operation is called with the arguments _durationFormat_ (which must be an object initialized as a DurationFormat) and _duration_ (which must be a Record with the fields enumerated in <emu-xref href="#table-duration-components"></emu-xref>), and creates the corresponding parts according to the effective locale and the formatting options of _durationFormat_. The following steps are taken:</p>

      <emu-alg>
        1. If _durationFormat_.[[Style]] is `"dotted"`, then
          1. <mark>TODO: [[formats]].[[dotted]] needs to be keyed by which fields are available in this case.</mark>
          1. Let _result_ be a new empty List.
          1. Let _template_ be _dataLocaleData_.[[formats]].[[dotted]].[[&lt;_pr_&gt;]].
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. For each element _patternPart_ in _patternParts_, in List order, do
            1. Let _p_ be _patternPart_.[[Type]].
            1. If _p_ is `"literal"`, then
              1. Append _patternPart_ to the end of _result_.
            1. Else if _duration_.[[&lt;_p_&gt;]] is not *undefined* and _p_ exists in _durationFormat_.[[Fields]], then
              1. Let _num_ be FormatNumeric(_durationFormat_.[[NumberFormat]], _duration_.[[&lt;_p_&gt;]]).
              1. Append the new Record { [[Type]]: _p_, [[Value]]: _num_ } to the end of _result_.
          1. Return _result_.
        1. Return ! PartitionDurationPattern(_duration_, _durationFormat_.[[DataLocale]], _durationFormat_.[[Style]], _durationFormat_.[[NumberFormat]], _durationFormat_.[[PluralRules]], _durationFormat_.[[ListFormat]], _durationFormat_.[[Fields]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-intl-durationformat-constructor">
    <h1>The Intl.DurationFormat Constructor</h1>

    <p>The DurationFormat constructor is the <dfn>%DurationFormat%</dfn> intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in <emu-xref href="#sec-internal-slots"></emu-xref>.</p>

    <emu-clause id="sec-Intl.DurationFormat">
      <h1>Intl.DurationFormat ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>When the `Intl.DurationFormat` function is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _durationFormat_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%DurationFormatPrototype%"`, &laquo; [[InitializedDurationFormat]], [[Locale]], [[DataLocale]], [[NumberingSystem]], [[Style]], [[Fields]] &raquo;).
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. If _options_ is *undefined*, then
          1. Let _options_ be ObjectCreate(*null*).
        1. Else,
          1. Let _options_ be ? ToObject(_options_).
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, `"localeMatcher"`, `"string"`, &laquo; `"lookup"`, `"best fit"` &raquo;, `"best fit"`).
        1. Set _opt_.[[localeMatcher]] to _matcher_.
        1. Let _numberingSystem_ be ? GetOption(_options_, `"numberingSystem"`, `"string"`, `undefined`, `undefined`).
        1. If _numberingSystem_ does not match the Unicode Locale Identifier `type` nonterminal, throw a `RangeError` exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Let _localeData_ be %DurationFormat%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%DurationFormat%.[[AvailableLocales]], _requestedLocales_, _opt_, %DurationFormat%.[[RelevantExtensionKeys]], _localeData_).
        1. Let _locale_ be r.[[locale]].
        1. Set _durationFormat_.[[Locale]] to _locale_.
        1. Set _durationFormat_.[[NumberingSystem]] to _r_.[[nu]].
        1. Let _style_ be ? GetOption(_options_, `"style"`, `"string"`, &laquo; `"long"`, `"short"`, `"narrow"`, `"dotted"` &raquo;, `"long"`).
        1. Set _durationFormat_.[[Style]] to _style_.
        1. Set _durationFormat_.[[DataLocale]] to _r_.[[dataLocale]].
        1. Let _fields_ be ? Get(_options_, `"fields"`).
        1. If _fields_ is *undefined*, then
          1. Let _list_ be a new empty List.
          1. For each row in <emu-xref href="#table-duration-components"></emu-xref>, except the header row, in table order, do
            1. Let _field_ be the Property value.
            1. Append _field_ as the last element of _list_.
          1. Set _durationFormat_.[[Fields]] to _list_.
        1. Else if IsArray(_fields_) is *true*, then
          1. Set _fields_ to ? CreateListFromArrayLike(_fields_).
          1. For each element _field_ in _fields_, in List order, do
            1. If _field_ isn't in <emu-xref href="#table-duration-components"></emu-xref>, then
              1. Throw a *RangeError* exception.
          1. Set _durationFormat_.[[Fields]] to _fields_.
        1. Else,
          1. Throw a *TypeError* exception.
        1. Set _durationFormat_.[[NumberFormat]] to ! Construct(%NumberFormat%, &laquo; _locale_ &raquo;).
        1. Set _durationFormat_.[[PluralRules]] to ! Construct(%PluralRules%, &laquo; _locale_ &raquo;).
        1. If _style_ is not `"dotted"`, then
          1. Set _durationFormat_.[[ListFormat]] to ! Construct(%ListFormat%, &laquo; _locale_ &raquo;).
        1. Return _durationFormat_.
      </emu-alg>
    </emu-clause>

    <emu-note type=editor>It's currently being discussed what the best API for field selection would be. For more information, check out the corresponding <a href="https://github.com/tc39/proposal-intl-duration-format/issues/3">Github thread</a>.</emu-note>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-durationformat-constructor">
    <h1>Properties of the Intl.DurationFormat Constructor</h1>

    <p>The Intl.DurationFormat constructor has the following properties:</p>

    <emu-clause id="sec-Intl.DurationFormat.prototype">
      <h1>Intl.DurationFormat.prototype</h1>

      <p>The value of `Intl.DurationFormat.prototype` is %DurationFormatPrototype%.</p>

      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-Intl.DurationFormat.supportedLocalesOf">
      <h1>Intl.DurationFormat.supportedLocalesOf ( _locales_ [ , _options_ ] )</h1>

      <p>When the `supportedLocalesOf` method is called with arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _availableLocales_ be %DurationFormat%.[[AvailableLocales]].
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. Return ? SupportedLocales(_availableLocales_, _requestedLocales_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.DurationFormat-internal-slots">
      <h1>Internal slots</h1>

      <p>The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref>.</p>

      <p>The value of the [[RelevantExtensionKeys]] internal slot is &laquo; `"nu"` &raquo;.</p>

      <p>The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref> and the following additional constraints for all locale values _locale_:</p>

      <ul>
        <li>[[LocaleData]].[[&lt;_locale_&gt;]].[[nu]] must be a List as specified in <emu-xref href="#sec-intl.numberformat-internal-slots"></emu-xref>.</li>
        <li>[[LocaleData]].[[&lt;_locale_&gt;]] must have a [[formats]] field. The value of this field must be a record, which must have fields with the names of the four formatting styles: `long`, `short`, `narrow`, and `dotted`. Each of first three fields must be records themselves, and each must have fields with the names of the supported units: `nanoseconds`, `microseconds`, `milliseconds`, `seconds`, `minutes`, `hours`, `days`, `weeks`, `months`, and `years`, which are Records with a field for each of the plural categories relevant for _locale_; the value corresponding to those fields is a pattern which may contain *"{0}"* to be replaced by a formatted number. The value of the fourth field, corresponding to the `dotted` style, on the other hand, must be a pattern; i.e. a String that contains for an arbitrary subset of the Duration component fields a substring starting with `"{"`, followed by the name of the field, followed by `"}"`.</li>
      </ul>

      <emu-note type=editor>TODO: [[formats]].[[dotted]] need to be keyed by the available fields.</emu-note>
      <emu-note>It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org/">http://cldr.unicode.org/</a>).</emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-durationformat-prototype-object">
    <h1>Properties of the Intl.DurationFormat Prototype Object</h1>

    <p>The Intl.DurationFormat prototype object is itself an ordinary object. <dfn>%DurationFormatPrototype%</dfn> is not an Intl.DurationFormat instance and does not have an [[InitializedDurationFormat]] internal slot or any of the other internal slots of Intl.DurationFormat instance objects.</p>

    <emu-clause id="sec-Intl.DurationFormat.prototype.constructor">
      <h1>Intl.DurationFormat.prototype.constructor</h1>

      <p>The initial value of `Intl.DurationFormat.prototype.constructor` is the intrinsic object %DurationFormat%.</p>
    </emu-clause>

    <emu-clause id="sec-Intl.DurationFormat.prototype-@@tostringtag">
      <h1>Intl.DurationFormat.prototype [ @@toStringTag ]</h1>

      <p>The initial value of the @@toStringTag property is the string value `"Intl.DurationFormat"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-Intl.DurationFormat.prototype.format">
      <h1>Intl.DurationFormat.prototype.format ( _duration_ )</h1>

      <p>When the `format` method is called with an argument _duration_, the following steps are taken:</p>

      <emu-alg>
        1. Let _df_ be *this* value.
        1. Perform ? RequireInternalSlot(_df_, [[InitializedDurationFormat]]).
        1. Let _record_ be ? ToPartialDuration(_duration_).
        1. Let _formatted_ be ? PartitionDurationFormatPattern(_df_, _duration_).
        1. Let _result_ be a new empty String.
        1. For each element _part_ in _formatted_, in List order, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>

      <emu-note type=editor>It's still being actively discussed if balancing should be done in DurationFormat. For more information, check out the <a href="https://github.com/tc39/proposal-intl-duration-format/issues/10">relevant github issue</a>.</emu-note>
    </emu-clause>
    <emu-clause id="sec-Intl.DurationFormat.prototype.formatToParts">
      <h1>Intl.DurationFormat.prototype.formatToParts ( _duration_ )</h1>

      <p>When the `formatToParts` method is called with an argument _duration_, the following steps are taken:</p>

      <emu-alg>
        1. Let _df_ be *this* value.
        1. Perform ? RequireInternalSlot(_df_, [[InitializedDurationFormat]]).
        1. Let _record_ be ? ToPartialDuration(_duration_).
        1. Let _formatted_ be ? PartitionDurationFormatPattern(_df_, _duration_).
        1. Let _result_ be ArrayCreate(0).
        1. Let _n_ be `0`.
        1. For each element _part_ in _formatted_, in List order, do
          1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"type"`, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"value"`, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(_n_), _obj_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-Intl.DurationFormat.prototype.resolvedOptions">
      <h1>Intl.DurationFormat.prototype.resolvedOptions ( )</h1>

      <p>This function provides access to the locale and options computed during initialization of the object.</p>

      <emu-alg>
        1. Let _df_ be the *this* value.
        1. Perform ? RequireInternalSlot(_df_, [[InitializedDurationFormat]]).
        1. Let _options_ be ! ObjectCreate(%ObjectPrototype%).
        1. For each row of <emu-xref href="#table-durationformat-resolvedoptions-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. Let _v_ be the value of _df_'s internal slot whose name is the Internal Slot value of the current row.
          1. Assert: _v_ is not *undefined*.
          1. Perform ! CreateDataPropertyOrThrow(_options_, _p_, _v_).
        1. Return _options_.
      </emu-alg>

      <emu-table id="table-durationformat-resolvedoptions-properties">
        <emu-caption>Resolved Options of DurationFormat Instances</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
            </tr>
          </thead>
          <tr>
            <td>[[Locale]]</td>
            <td>`"locale"`</td>
          </tr>
          <tr>
            <td>[[NumberingSystem]]</td>
            <td>`"numberingSystem"`</td>
          </tr>
          <tr>
            <td>[[Style]]</td>
            <td>`"style"`</td>
          </tr>
          <tr>
            <td>[[Fields]]</td>
            <td>`"fields"`</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-durationformat-instances">
    <h1>Properties of Intl.DurationFormat Instances</h1>

    <p>Intl.DurationFormat instances inherit properties from %DurationFormatPrototype%.</p>

    <p>Intl.DurationFormat instances have an [[InitializedDurationFormat]] internal slot.</p>

    <p>Intl.DurationFormat instances also have several internal slots that are computed by the constructor:</p>

    <ul>
      <li>[[Locale]] is a String value with the language tag of the locale whose localization is used for formatting.</li>
      <li>[[DataLocale]] is a String value with the language tag of the nearest locale for which the implementation has data to perform the formatting operation. It will be a parent locale of [[Locale]].</li>
      <li>[[NumberingSystem]] is a String value with the `"type"` given in Unicode Technical Standard 35 for the numbering system used for formatting.</li>
      <li>[[Style]] is one of the String values `"long"`, `"short"`, `"narrow"`, or `"dotted"` identifying the duration formatting style used.</li>
      <li>[[Fields]] is a List value specifying which duration fields are required to be printed.</li>
      <li>[[NumberFormat]] is an Intl.NumberFormat object used for formatting.</li>
      <li>[[PluralRules]] is an Intl.PluralRules object used for formatting.</li>
      <li>[[ListFormat]] is an Intl.ListFormat object used for formatting.</li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-changes-to-ecma-402">
  <h1>Changes to ECMA 402</h1>

  <emu-clause id="listformat-objects">
    <h1>ListFormat Objects</h1>
    <emu-clause id="sec-createpartsfromrecordlist" aoid="CreatePartsFromRecordList">
      <h1>CreatePartsFrom<ins>Record</ins>List ( _listFormat_, _list_ )</h1>

      <p>
        The CreatePartsFrom<ins>Record</ins>List abstract operation is called with arguments _listFormat_ (which must be an object initialized as a ListFormat) and _list_ (which must be a List of <del>String</del><ins>Record</ins> values), and creates the corresponding list of parts according to the effective locale and the formatting options of _listFormat_.
        Each part is a Record with two fields: [[Type]], which must be a string with values "element" or "literal", and [[Value]] which must be a string or a number.
        The following steps are taken:
      </p>

      <emu-alg>
        1. Let _size_ be the number of elements of _list_.
        1. If _size_ is 0, then
          1. Return a new empty List.
        1. If _size_ is 2, then
          1. Let _n_ be an index into _listFormat_.[[Templates]] based on _listFormat_.[[Locale]], _list_[0], and _list_[1].
          1. Let _pattern_ be _listFormat_.[[Templates]][_n_].[[Pair]].
          1. <del>Let _first_ be a new Record { [[Type]]: *"element"*, [[Value]]: _list_[0] }.</del>
          1. <del>Let _second_ be a new Record { [[Type]]: *"element"*, [[Value]]: _list_[1] }.</del>
          1. <del>Let _placeables_ be a new Record { [[0]]: _first_, [[1]]: _second_ }.</del>
          1. <ins>Let _placeables_ be a new Record { [[0]]: _list_[0], [[1]]: _list_[1] }.</ins>
          1. Return DeconstructPattern(_pattern_, _placeables_).
        1. <del>Let _last_ be a new Record { [[Type]]: *"element"*, [[Value]]: _list_[_size_ - 1] }.</del>
        1. <del>Let _parts_ be &laquo; _last_ &raquo;.</del>
        1. <ins>Let _parts_ be &laquo; _list_[_size_ - 1] &raquo;.</ins>
        1. Let _i_ be _size_ - 2.
        1. Repeat, while _i_ &ge; 0
          1. Let _n_ be an implementation-defined index into _listFormat_.[[Templates]] based on _listFormat_.[[Locale]], _head_, and _parts_.
          1. If _i_ is 0, then
            1. Let _pattern_ be _listFormat_.[[Templates]][_n_].[[Start]].
          1. Else, if _i_ is less than _size_ - 2, then
            1. Let _pattern_ be _listFormat_.[[Templates]][_n_].[[Middle]].
          1. Else,
            1. Let _pattern_ be _listFormat_.[[Templates]][_n_].[[End]].
          1. <del>Let _head_ be a new Record { [[Type]]: *"element"*, [[Value]]: _list_[_i_] }.</del>
          1. <del>Let _placeables_ be a new Record { [[0]]: _head_, [[1]]: _parts_ }.</del>
          1. <ins>Let _placeables_ be a new Record { [[0]]: _list_[_i_], [[1]]: _parts_ }.</ins>
          1. Set _parts_ to DeconstructPattern(_pattern_, _placeables_).
          1. Decrement _i_ by 1.
        1. Return _parts_.
      </emu-alg>

      <emu-note>
        The index _n_ to select across multiple templates permits the conjunction to be dependent on the context, as in Spanish, where "y" or "e" may be selected, dependending on the following word.
      </emu-note>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-createpartsfromstringlist" aoid="CreatePartsFromStringList">
      <h1>CreatePartsFromStringList ( _listFormat_, _list_ )</h1>

      <p>
        The CreatePartsFromStringList abstract operation is called with arguments _listFormat_ (which must be an object initialized as a ListFormat) and _list_ (which must be a List of String values), and creates the corresponding list of parts according to the effective locale and the formatting options of _listFormat_.
        Each part is a Record with two fields: [[Type]], which must be a string with values "element" or "literal", and [[Value]] which must be a string or a number.
        The following steps are taken:
      </p>

      <emu-alg>
        1. Let _recordList_ be « ».
        1. For each element _s_ of _list_ in List order, do
          1. Append a new Record { [[Type]]: `"element"`, [[Value]]: _s_ } to _recordList_.
        1. Return ! CreatePartsFromRecordList(_listFormat_, _recordList_).
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-formatlist" aoid="FormatList">
      <h1>FormatList ( _listFormat_, _list_ )</h1>

      <p>
        The FormatList abstract operation is called with arguments _listFormat_ (which must be an object initialized as a ListFormat) and _list_ (which must be a List of String values), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be <del>CreatePartsFromList</del><ins>CreatePartsFromStringList</ins>(_listFormat_, _list_).
        1. Let _result_ be an empty String.
        1. For each _part_ in _parts_, do
          1. Set _result_ to a String value produced by concatenating _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatlisttoparts" aoid="FormatListToParts">
      <h1>FormatListToParts ( _listFormat_, _list_ )</h1>

      <p>
        The FormatListToParts abstract operation is called with arguments _listFormat_ (which must be an object initialized as a ListFormat) and _list_ (which must be a List of String values), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be <del>CreatePartsFromList</del><ins>CreatePartsFromStringList</ins>(_listFormat_, _list_).
        1. Let _result_ be ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each _part_ in _parts_, do
          1. Let _O_ be ObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(_n_), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="relativetimeformat-objects">
    <h1>RelativeTimeFormat Objects</h1>

    <emu-clause id="sec-InitializeRelativeTimeFormat" aoid="InitializeRelativeTimeFormat">
      <h1>InitializeRelativeTimeFormat ( _relativeTimeFormat_, _locales_, _options_ )</h1>

      <p>
        The abstract operation InitializeRelativeTimeFormat accepts the arguments _relativeTimeFormat_ (which must be an object), _locales_, and _options_. It initializes _relativeTimeFormat_ as a RelativeTimeFormat object.
      </p>
      <p>
        The following algorithm refers to <a href="https://www.unicode.org/reports/tr35/#Identifiers">UTS 35's Unicode Language and Locale Identifiers grammar</a>.
        The following steps are taken:
      </p>

      <emu-alg>
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. If _options_ is *undefined*, then
          1. Let _options_ be ObjectCreate(*null*).
        1. Else,
          1. Let _options_ be ? ToObject(_options_).
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, *"localeMatcher"*, *"string"*, «*"lookup"*, *"best fit"*», *"best fit"*).
        1. Set _opt_.[[LocaleMatcher]] to _matcher_.
        1. Let _numberingSystem_ be ? GetOption(_options_, *"numberingSystem"*, *"string"*, *undefined*, *undefined*).
        1. If _numberingSystem_ is not *undefined*, then
          1. If _numberingSystem_ does not match the `type` sequence (from <a href="https://unicode.org/reports/tr35/#Unicode_locale_identifier">UTS 35 Unicode Locale Identifier, section 3.2</a>), throw a *RangeError* exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Let _localeData_ be %RelativeTimeFormat%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%RelativeTimeFormat%.[[AvailableLocales]], _requestedLocales_, _opt_, %RelativeTimeFormat%.[[RelevantExtensionKeys]], _localeData_).
        1. Let _locale_ be _r_.[[locale]].
        1. Set _relativeTimeFormat_.[[Locale]] to _locale_.
        1. Set _relativeTimeFormat_.[[DataLocale]] to _r_.[[dataLocale]].
        1. Set _relativeTimeFormat_.[[NumberingSystem]] to _r_.[[nu]].
        1. Let _s_ be ? GetOption(_options_, *"style"*, *"string"*, «*"long"*, *"short"*, *"narrow"*», *"long"*).
        1. Set _relativeTimeFormat_.[[Style]] to _s_.
        1. Let _numeric_ be ? GetOption(_options_, *"numeric"*, *"string"*, «*"always"*, *"auto"*», *"always"*).
        1. Set _relativeTimeFormat_.[[Numeric]] to _numeric_.
        1. Let _relativeTimeFormat_.[[NumberFormat]] be ! Construct(%NumberFormat%, « _locale_ »).
        1. Let _relativeTimeFormat_.[[PluralRules]] be ! Construct(%PluralRules%, « _locale_ »).
        1. <ins>Let _lfOptions_ be ? ObjectCreate(*null*).</ins>
        1. <ins>Perform ! CreateDataPropertyOrThrow(_lfOptions_, *"style"*, _s_).</ins>
        1. <ins>Set _relativeTimeFormat_.[[ListFormat]] to ! Construct(%ListFormat%, « _locale_, _lfOptions_ »).</ins>
        1. Return _relativeTimeFormat_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-PartitionRelativeTimePatternDuration" aoid="PartitionRelativeTimePatternDuration">
      <h1>PartitionRelativeTimePatternDuration ( _relativeTimeFormat_, _duration_ )</h1>

      <p>
        When the PartitionRelativeTimePatternDuration abstract operation is called with arguments _relativeTimeFormat_ and _duration_ it returns a String value representing _duration_ (which must be a Duration object) according to the effective locale and the formatting options of _relativeTimeFormat_.
      </p>

      <emu-alg>
        1. Assert: _relativeTimeFormat_ has an [[InitializedRelativeTimeFormat]] internal slot.
        1. Assert: Type(_duration_) is Object.
        1. Assert: _duration_ has an [[InitializedTemporalDuration]] internal slot.
        1. Let _localeData_ be %RelativeTimeFormat%.[[LocaleData]].
        1. Let _dataLocale_ be _relativeTimeFormat_.[[DataLocale]].
        1. Let _patterns_ be _localeData_.[[&lt;_dataLocale_&gt;]].[[duration]].
        1. Let _sign_ be ! DurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. If _sign_ is −1, then
          1. Let _tl_ be *"past"*.
        1. Else,
          1. Assert: _sign_ is 0 or 1.
          1. Let _tl_ be *"future"*.
        1. Let _po_ be _patterns_.[[&lt;_tl_&gt;]].
        1. Let _listParts_ be ! PartitionDurationPattern(_duration_, _dataLocale_, _relativeTimeFormat_.[[NumberFormat]], _relativeTimeFormat_.[[PluralRules]], _relativeTimeFormat_.[[ListFormat]]).
        1. Let _placeables_ be the Record { [[0]]: _listParts_ }.
        1. Return ! DeconstructPattern(_po_, _placeables_).
      </emu-alg>

      <emu-table id="table-temporalduration-properties">
        <emu-caption>Properties of a Temporal.Duration object</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Unit</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Years]]</td>
              <td>*"year"*</td>
            </tr>
            <tr>
              <td>[[Months]]</td>
              <td>*"month"*</td>
            </tr>
            <tr>
              <td>[[Weeks]]</td>
              <td>*"week"*</td>
            </tr>
            <tr>
              <td>[[Days]]</td>
              <td>*"day"*</td>
            </tr>
            <tr>
              <td>[[Hours]]</td>
              <td>*"hour"*</td>
            </tr>
            <tr>
              <td>[[Minutes]]</td>
              <td>*"minute"*</td>
            </tr>
            <tr>
              <td>[[Seconds]]</td>
              <td>*"second"*</td>
            </tr>
            <tr>
              <td>[[Milliseconds]]</td>
              <td>*"millisecond"*</td>
            </tr>
            <tr>
              <td>[[Microseconds]]</td>
              <td>*"microsecond"*</td>
            </tr>
            <tr>
              <td>[[Nanoseconds]]</td>
              <td>*"nanosecond"*</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-FormatRelativeTimeDuration" aoid="FormatRelativeTimeDuration">
      <h1>FormatRelativeTimeDuration ( _relativeTimeFormat_, _duration_ )</h1>

      <p>
        The FormatRelativeTimeDuration abstract operation is called with arguments _relativeTimeFormat_ (which must be an object initialized as a RelativeTimeFormat) and _duration_ (which must be a Duration object) and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionRelativeTimePatternDuration(_relativeTimeFormat_, _duration_).
        1. Let _result_ be an empty String.
        1. For each Record _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-FormatRelativeTimeToPartsDuration" aoid="FormatRelativeTimeToPartsDuration">
      <h1>FormatRelativeTimeToPartsDuration ( _relativeTimeFormat_, _duration_ )</h1>

      <p>
        The FormatRelativeTimeToPartsDuration abstract operation is called with arguments _relativeTimeFormat_ (which must be an object initialized as a RelativeTimeFormat) and _duration_ (which must be a Duration object) and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionRelativeTimePatternDuration(_relativeTimeFormat_, _duration_).
        1. Let _result_ be ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record _part_ in _parts_, do
          1. Let _O_ be ObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. If _part_ has a [[Unit]] field, then
            1. Perform ! CreateDataPropertyOrThrow(_O_, *"unit"*, _part_.[[Unit]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(_n_), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-Intl.RelativeTimeFormat">
      <h1>Intl.RelativeTimeFormat ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>
        When the *Intl.RelativeTimeFormat* function is called with optional arguments the following steps are taken:
      </p>

      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _relativeTimeFormat_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%RelativeTimeFormat.prototype%"*, « [[InitializedRelativeTimeFormat]], [[Locale]], [[DataLocale]], [[Style]], [[Numeric]], [[NumberFormat]], [[NumberingSystem]], [[PluralRules]]<ins>, [[ListFormat]]</ins> »).
        1. Return ? InitializeRelativeTimeFormat(_relativeTimeFormat_, _locales_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.RelativeTimeFormat-internal-slots">
      <h1>Internal slots</h1>

      <p>
        The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref>.
      </p>

      <p>
        The value of the [[RelevantExtensionKeys]] internal slot is « *"nu"* ».
      </p>

      <emu-note>
        Unicode Technical Standard 35 describes one locale extension key that is relevant to relative time formatting: *"nu"* for numbering system (of formatted numbers).
      </emu-note>

      <p>
        The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref> and the following additional constraints, for all locale values _locale_:
      </p>

      <ul>
        <li>[[LocaleData]][&lt;_locale_&gt;] has fields *"second"*, *"minute"*, *"hour"*, *"day"*, *"week"*, *"month"*, *"quarter"*, <del>and</del> *"year"*<ins>, and *"duration"*</ins>. Additional fields may exist with the previous names concatenated with the strings *"-narrow"* or *"-short"*. The values corresponding to these fields are Records which contain these two categories of fields:
        <ul>
        <li>*"future"* and *"past"* fields, which are Records with a field for each of the plural categories relevant for _locale_. The value corresponding to those fields is a pattern which may contain *"{0}"* to be replaced by a formatted number<ins>, or in the *"duration"* case, by a formatted duration</ins>.</li>
        <li>Optionally, <ins>but not in the *"duration"* case,</ins> additional fields whose key is the result of ToString of a Number, and whose values are literal Strings which are not treated as templates.</li>
        </ul>
        </li>
        <li>
          The list that is the value of the *"nu"* field of any locale field of [[LocaleData]] must not include the values *"native"*, *"traditio"*, or *"finance"*.
        </li>
      </ul>

      <emu-note>
        It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org/">http://cldr.unicode.org/</a>).
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-Intl.RelativeTimeFormat.prototype.format">
      <h1>Intl.RelativeTimeFormat.prototype.format ( _value_, _unit_ )</h1>

      <p>
        When the `format` method is called with arguments _value_ and _unit_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _relativeTimeFormat_ be the *this* value.
        1. Perform ? RequireInternalSlot(_relativeTimeFormat_, [[InitializedRelativeTimeFormat]]).
        1. <ins>If _unit_ is *undefined*, then</ins>
          1. <ins>Let _duration_ be ? ToTemporalDuration(_value_).</ins>
          1. <ins>Return ? FormatRelativeTimeDuration(_relativeTimeFormat_, _duration_).</ins>
        1. Let _value_ be ? ToNumber(_value_).
        1. Let _unit_ be ? ToString(_unit_).
        1. Return ? FormatRelativeTime(_relativeTimeFormat_, _value_, _unit_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.RelativeTimeFormat.prototype.formatToParts">
      <h1>Intl.RelativeTimeFormat.prototype.formatToParts ( _value_, _unit_ )</h1>

      <p>
        When the `formatToParts` method is called with arguments _value_ and _unit_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _relativeTimeFormat_ be the *this* value.
        1. Perform ? RequireInternalSlot(_relativeTimeFormat_, [[InitializedRelativeTimeFormat]]).
        1. <ins>If _unit_ is *undefined*, then</ins>
          1. <ins>Let _duration_ be ? ToTemporalDuration(_value_).</ins>
          1. <ins>Return ? FormatRelativeTimeToPartsDuration(_relativeTimeFormat_, _duration_).</ins>
        1. Let _value_ be ? ToNumber(_value_).
        1. Let _unit_ be ? ToString(_unit_).
        1. Return ? FormatRelativeTimeToParts(_relativeTimeFormat_, _value_, _unit_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
